stages:
  - test
  - build
  - quality
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  POSTGRES_DB: telegram_assistant_test
  POSTGRES_USER: test_user
  POSTGRES_PASSWORD: test_password

# --- TEST STAGE ---
test:backend:
  stage: test
  image: python:3.11
  services:
    - postgres:13
  variables:
    DATABASE_URL: postgresql://$POSTGRES_USER:$POSTGRES_PASSWORD@postgres:5432/$POSTGRES_DB
  before_script:
    - cd App/Backend
    - pip install -r requirements.txt pytest pytest-cov pytest-asyncio
  script:
    - python -m pytest ../../tests/quality -v --cov=. --cov-report=xml --junitxml=junit.xml
  coverage: '/TOTAL.*\s+(\d+%)$/'
  artifacts:
    reports:
      junit: App/Backend/junit.xml
    paths:
      - App/Backend/coverage.xml
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    - if: $CI_COMMIT_BRANCH == 'main' || $CI_COMMIT_BRANCH == 'develop'

# Объединенный фронтенд-тест для всех приложений
test:frontend:
  stage: test
  image: node:18
  parallel:
    matrix:
      - APP_DIR: ["client-app", "manager-app", "assistant-app"]
  before_script:
    - cd App/Frontend/${APP_DIR}
    - npm ci
  script:
    - npm run test -- --coverage --watchAll=false
    - npm run lint
  artifacts:
    reports:
      junit: App/Frontend/${APP_DIR}/junit.xml
    paths:
      - App/Frontend/${APP_DIR}/coverage/cobertura-coverage.xml
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    - if: $CI_COMMIT_BRANCH == 'main' || $CI_COMMIT_BRANCH == 'develop'

# --- STATIC ANALYSIS ---
static_analysis:python:
  stage: test
  image: python:3.11
  before_script:
    - cd App/Backend
    - pip install black flake8 mypy bandit safety
  script:
    - black --check --diff .
    - flake8 .
    - mypy app/
    - bandit -r app/ -ll
    - safety check --full-report
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'

static_analysis:javascript:
  stage: test
  image: node:18
  before_script:
    - cd App/Frontend/client-app
    - npm ci
  script:
    - npm run lint
    - npm run type-check
    - npm audit --audit-level moderate
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'

# --- BUILD STAGE ---
build:backend:
  stage: build
  image: python:3.11
  before_script:
    - cd App/Backend
    - pip install -r requirements.txt
  script:
    - python -m compileall app/
    - echo "Backend build successful"
  artifacts:
    paths:
      - App/Backend/
    expire_in: 1 hour
  rules:
    - if: $CI_COMMIT_BRANCH == 'main' || $CI_COMMIT_BRANCH == 'develop'

build:frontend:
  stage: build
  image: node:18
  parallel:
    matrix:
      - APP_DIR: ["client-app", "manager-app", "assistant-app"]
  script:
    - cd App/Frontend/${APP_DIR}
    - npm ci
    - npm run build
  artifacts:
    paths:
      - App/Frontend/${APP_DIR}/build/
    expire_in: 1 hour
  rules:
    - if: $CI_COMMIT_BRANCH == 'main' || $CI_COMMIT_BRANCH == 'develop'

# --- QUALITY STAGE ---
test:e2e:
  stage: quality
  image: cypress/included:12.17.0
  services:
    - name: postgres:13
      alias: postgres
    - name: python:3.11
      alias: backend
    - name: node:18
      alias: frontend
  variables:
    CYPRESS_baseUrl: http://frontend:3000
    BACKEND_URL: http://backend:8000
    DATABASE_URL: postgresql://$POSTGRES_USER:$POSTGRES_PASSWORD@postgres:5432/$POSTGRES_DB
  before_script:
    - cd App/Backend
    - pip install -r requirements.txt
    - python init_db.py
    - uvicorn main:app --host 0.0.0.0 --port 8000 &
    - cd ../Frontend/client-app
    - npm ci
    - npm start &
    - npx wait-on -t 30000 $BACKEND_URL $CYPRESS_baseUrl
  script:
    - npx cypress run
  artifacts:
    when: always
    paths:
      - App/Frontend/client-app/cypress/videos/
      - App/Frontend/client-app/cypress/screenshots/
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == 'main' || $CI_COMMIT_BRANCH == 'develop'

# --- DEPLOY STAGE ---

# [Изменено] Деплой только бэкенда и бота на сервер
deploy:backend:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client rsync
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $PRODUCTION_SERVER >> ~/.ssh/known_hosts
  script:
    # Копируем только нужные для бэкенда части
    - rsync -avz --delete App/Backend/ root@$PRODUCTION_SERVER:/root/project/App/Backend
    - rsync -avz --delete App/bot/ root@$PRODUCTION_SERVER:/root/project/App/bot
    - |
      ssh root@$PRODUCTION_SERVER << 'EOF'
        echo "--- Starting backend deployment ---"
        cd /root/project/App/Backend
        echo "--- Installing dependencies ---"
        pip install -r requirements.txt
        echo "--- Stopping existing server ---"
        pkill -f "uvicorn main:app" || echo "No existing process to kill."
        sleep 2
        echo "--- Starting new server in background ---"
        nohup uvicorn main:app --host 0.0.0.0 --port 8000 > /root/project/nohup.out 2>&1 &
        sleep 2
        echo "--- Checking server status ---"
        pgrep -f "uvicorn main:app" && echo "Server is running." || echo "Server failed to start."
        echo "--- Deployment finished ---"
      EOF
  environment:
    name: production
    url: https://api.rent-assistant.ru
  rules:
    - if: $CI_COMMIT_BRANCH == 'main'
      when: manual

# [Новое] Деплой фронтенд-приложений в Vercel
deploy:frontend:
  stage: deploy
  image: node:18
  parallel:
    matrix:
      - APP_DIR: ["client-app", "manager-app", "assistant-app"]
  before_script:
    - npm install -g vercel
  script:
    - cd App/Frontend/${APP_DIR}
    # Устанавливаем правильный Project ID для каждого приложения
    - |
      if [ "$APP_DIR" = "client-app" ]; then
        PROJECT_ID=$VERCEL_PROJECT_ID_CLIENT
      elif [ "$APP_DIR" = "manager-app" ]; then
        PROJECT_ID=$VERCEL_PROJECT_ID_MANAGER
      elif [ "$APP_DIR" = "assistant-app" ]; then
        PROJECT_ID=$VERCEL_PROJECT_ID_ASSISTANT
      fi
    # Создаем .vercel/project.json для связи с проектом Vercel
    - mkdir -p .vercel
    - echo "{\"projectId\":\"$PROJECT_ID\",\"orgId\":\"$VERCEL_ORG_ID\"}" > .vercel/project.json
    # Создаем build-артефакты
    - npm ci
    - npm run build
    # Деплоим в Vercel. Флаг --scope не нужен, т.к. orgId есть в project.json
    - vercel --prod --token $VERCEL_TOKEN --yes
  rules:
    - if: $CI_COMMIT_BRANCH == 'main'

# Деплой фронтенда на staging (Vercel Preview)
deploy:frontend:staging:
  stage: deploy
  image: node:18
  parallel:
    matrix:
      - APP_DIR: ["client-app", "manager-app", "assistant-app"]
  before_script:
    - npm install -g vercel
  script:
    - cd App/Frontend/${APP_DIR}
    # Устанавливаем правильный Project ID для каждого приложения
    - |
      if [ "$APP_DIR" = "client-app" ]; then
        PROJECT_ID=$VERCEL_PROJECT_ID_CLIENT
      elif [ "$APP_DIR" = "manager-app" ]; then
        PROJECT_ID=$VERCEL_PROJECT_ID_MANAGER
      elif [ "$APP_DIR" = "assistant-app" ]; then
        PROJECT_ID=$VERCEL_PROJECT_ID_ASSISTANT
      fi
    # Создаем .vercel/project.json для связи с проектом Vercel
    - mkdir -p .vercel
    - echo "{\"projectId\":\"$PROJECT_ID\",\"orgId\":\"$VERCEL_ORG_ID\"}" > .vercel/project.json
    # Создаем build-артефакты
    - npm ci
    - npm run build
    # Деплоим в Vercel как preview. Vercel CLI автоматически определит, что это не продакшн.
    - vercel --token $VERCEL_TOKEN --yes
  rules:
    - if: $CI_COMMIT_BRANCH == 'develop'


# Деплой бэкенда на staging
deploy:backend:staging:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client rsync
    - eval $(ssh-agent -s)
    - echo "$STAGING_SSH_PRIVATE_KEY" | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $STAGING_SERVER >> ~/.ssh/known_hosts
  script:
    # Копируем только бэкенд
    - rsync -avz --delete App/Backend/ root@$STAGING_SERVER:/root/project/App/Backend
    - rsync -avz --delete App/bot/ root@$STAGING_SERVER:/root/project/App/bot
    - |
      ssh root@$STAGING_SERVER << 'EOF'
        echo "--- Starting backend deployment on staging ---"
        cd /root/project/App/Backend

        echo "--- Installing dependencies ---"
        pip install -r requirements.txt

        echo "--- Stopping existing staging server ---"
        pkill -f "uvicorn main:app --port 8001" || echo "No existing staging process to kill."
        sleep 2

        echo "--- Starting new staging server in background on port 8001 ---"
        # Используем отдельный файл БД для staging
        export DATABASE_URL="sqlite:///./staging_test.db" 
        nohup uvicorn main:app --host 0.0.0.0 --port 8001 > /root/project/nohup_staging.out 2>&1 &
        sleep 2

        echo "--- Checking server status ---"
        pgrep -f "uvicorn main:app --port 8001" && echo "Staging server is running." || echo "Server failed to start."
        echo "--- Deployment finished ---"
      EOF
  environment:
    name: staging
    url: https://api.staging.rent-assistant.ru
  rules:
    - if: $CI_COMMIT_BRANCH == 'develop'
      when: manual

# --- POST OPERATIONS ---
cleanup:
  stage: .post
  image: alpine:latest
  script:
    - echo "Cleaning up temporary files..."
  when: always